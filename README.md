# CiCdOptimizationsForMicroservices

<a alt="Nx logo" href="https://nx.dev" target="_blank" rel="noreferrer"><img src="https://raw.githubusercontent.com/nrwl/nx/master/images/nx-logo.png" width="45"></a>

✨ **This workspace has been generated by [Nx, Smart Monorepos · Fast CI.](https://nx.dev)** ✨

Yeah, we know - Nx is magic and yada yada.

... and the rest are just [Nick's](www.nickminaev.com) tinkerings. 

What am I tinkering with now?

Basically, I'm trying to optimize this puppy to work with Docker based on the microservices pattern.

# Our heros

We have here three microservices, called `cats-service`, `dogs-service` and `parrots-service`.
These are NestJS applications that share a `Guard` called `auth-guard`. This guy resides under the `libs` directory.

The above applications are containerized and then they're ought to be shipped to some cloud (say AWS).

But there's a teeny tiny caveat: I don't want to use the Nx cloud to build the applications.

# What I've tinkered with so far?

1. Set a shiny a new _default target_ for the repo (under the `nx.json` file):
```json
...
"targetDefaults": {
    "docker-build": {
      "executor": "nx:run-commands",
      "options": {
        "commands": [
          {
            "command": "version=$(cat {projectRoot}/package.json | jq .version | tr -d '\",\"\"' ); docker build --build-arg='TARGET_APP={projectName}' . -t {projectName}:$version "
          }
        ]
      }
    }
    ...
```

What does this target do? Well, it runs several commands, such as: `version=$(cat {projectRoot}/package.json | jq .version | tr -d '\",\"\"' )`.

What are those `{projectRoot}` and `{projectName}` thingies?

Basically, these are Nx's default variables that you use to reference a project's name and its directory.
I tinkered especially with the `{projectName}` and I was happy to find out I could pass the project name along.

Go on, Nick, said no-one.

The command above uses `jq` to parse JSON and read the version of the application, then I remove unneeded characters.

Afterwards, I just `docker build` the application in question.

To avoid DRY, I set this default target once and I can now skip rewriting it for every new shiny project in the repo. Isn't it cool?

Wait for it, I can also run now severl `docker build` commands in parallel! Now, it's the best kind on the block.

## The magical Dockerfile

I decided there would be a single Dockerfile with purpose of maintainability and unity. By now you can definitely tell, I dread the DRY creature.

Hence, single Dockerfile. What happens if it suffers from vulnerabilities at the OS or NodeJS level?

We just upgrade & test the changes for everything at once.



